"""Code generator for ADK Playground projects.

Generates complete, runnable Python code from a Project that can be executed
with `adk run` or `adk web`. The generated code is self-contained and includes
all custom tools, callbacks, and agent definitions inline.
"""

from __future__ import annotations

import json
import re
import textwrap
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from models import (
    Project, AppConfig, AgentConfig, LlmAgentConfig, SequentialAgentConfig,
    LoopAgentConfig, ParallelAgentConfig, ToolConfig, FunctionToolConfig,
    MCPToolConfig, BuiltinToolConfig, SkillSetToolConfig, AgentToolConfig,
    ModelConfig, CustomToolDefinition, CustomCallbackDefinition, CallbackConfig,
)


def _escape_string(s: str) -> str:
    """Escape a string for use in Python code."""
    return s.replace('\\', '\\\\').replace('"""', '\\"\\"\\"')


def _to_valid_identifier(name: str) -> str:
    """Convert a name to a valid Python identifier."""
    # Replace non-alphanumeric chars with underscore
    result = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    # Ensure it doesn't start with a digit
    if result and result[0].isdigit():
        result = '_' + result
    return result or 'unnamed'


def _get_function_name_from_code(code: str) -> Optional[str]:
    """Extract the function name from Python code."""
    # Look for "def function_name("
    match = re.search(r'^def\s+(\w+)\s*\(', code, re.MULTILINE)
    if match:
        return match.group(1)
    # Also check for "async def function_name("
    match = re.search(r'^async\s+def\s+(\w+)\s*\(', code, re.MULTILINE)
    if match:
        return match.group(1)
    return None


def _strip_imports_from_code(code: str) -> tuple[str, set[str]]:
    """Strip import statements from code and return the remaining code plus imports.
    
    Returns:
        Tuple of (code_without_imports, set_of_import_lines)
    """
    lines = code.strip().split('\n')
    imports = set()
    code_lines = []
    
    for line in lines:
        stripped = line.strip()
        if stripped.startswith('from ') or stripped.startswith('import '):
            imports.add(stripped)
        elif stripped == '' and not code_lines:
            # Skip leading empty lines
            continue
        else:
            code_lines.append(line)
    
    return '\n'.join(code_lines), imports


class CodeGenerator:
    """Generates runnable Python code from a Project."""
    
    def __init__(self, project: Project):
        self.project = project
        self.imports: Set[str] = set()
        self.agent_var_names: Dict[str, str] = {}
        self._collected_imports: Set[str] = set()
        
        # Build agent variable name mapping
        for agent in project.agents:
            var_name = _to_valid_identifier(agent.name)
            if not var_name.endswith('_agent'):
                var_name = f"{var_name}_agent"
            self.agent_var_names[agent.id] = var_name
    
    def generate(self) -> str:
        """Generate the complete Python code."""
        sections = []
        
        # Header
        sections.append(self._generate_header())
        
        # Environment variables section (as comments - user should set these)
        env_section = self._generate_env_vars()
        if env_section:
            sections.append(env_section)
        
        # Collect all code first to gather imports
        custom_tools_code = self._generate_custom_tools()
        custom_callbacks_code = self._generate_custom_callbacks()
        mcp_toolsets_code = self._generate_mcp_toolsets()
        skillsets_code = self._generate_skillsets()
        models_code = self._generate_models()
        agents_code = self._generate_agents()
        app_code = self._generate_app()
        
        # Now generate imports (after collecting from all code)
        sections.append(self._generate_imports())
        
        # Add sections in order
        if custom_tools_code:
            sections.append(custom_tools_code)
        if custom_callbacks_code:
            sections.append(custom_callbacks_code)
        if mcp_toolsets_code:
            sections.append(mcp_toolsets_code)
        if skillsets_code:
            sections.append(skillsets_code)
        if models_code:
            sections.append(models_code)
        if agents_code:
            sections.append(agents_code)
        if app_code:
            sections.append(app_code)
        
        return '\n\n'.join(filter(None, sections))
    
    def _generate_header(self) -> str:
        """Generate the header docstring."""
        lines = ['"""']
        lines.append(f"{self.project.name} - Generated by ADK Playground")
        if self.project.description:
            lines.append('')
            lines.append(self.project.description)
        lines.append('')
        lines.append('This code can be run with:')
        lines.append('  adk run .')
        lines.append('  adk web .')
        lines.append('"""')
        return '\n'.join(lines)
    
    def _generate_env_vars(self) -> str:
        """Generate environment variable setup (as comments)."""
        env_vars = self.project.app.env_vars or {}
        if not env_vars:
            return ''
        
        lines = ['# Environment Variables', '# Set these before running:']
        for key, value in env_vars.items():
            if value:
                # Mask sensitive values
                is_sensitive = 'key' in key.lower() or 'secret' in key.lower() or 'token' in key.lower()
                display_value = '***' if is_sensitive else value
                lines.append(f'# export {key}="{display_value}"')
            else:
                lines.append(f'# export {key}=""  # TODO: Set this')
        return '\n'.join(lines)
    
    def _generate_imports(self) -> str:
        """Generate import statements."""
        imports = set()
        
        # Always need Agent
        imports.add('from google.adk.agents import Agent')
        
        # Check agent types
        has_sequential = any(a.type == 'SequentialAgent' for a in self.project.agents)
        has_loop = any(a.type == 'LoopAgent' for a in self.project.agents)
        has_parallel = any(a.type == 'ParallelAgent' for a in self.project.agents)
        
        if has_sequential:
            imports.add('from google.adk.agents import SequentialAgent')
        if has_loop:
            imports.add('from google.adk.agents import LoopAgent')
        if has_parallel:
            imports.add('from google.adk.agents import ParallelAgent')
        
        # Check for model types
        has_litellm = any(
            a.type == 'LlmAgent' and a.model and a.model.provider == 'litellm'
            for a in self.project.agents
        )
        has_anthropic = any(
            a.type == 'LlmAgent' and a.model and a.model.provider == 'anthropic'
            for a in self.project.agents
        )
        
        if has_litellm:
            imports.add('from google.adk.models.lite_llm import LiteLlm')
        if has_anthropic:
            imports.add('from google.adk.models.anthropic_llm import Claude')
        
        # Check for tools
        has_agent_tool = any(
            a.type == 'LlmAgent' and any(t.type == 'agent' for t in a.tools)
            for a in self.project.agents
        )
        if has_agent_tool:
            imports.add('from google.adk.tools import AgentTool')
        
        # Built-in tools
        builtin_tools = set()
        for agent in self.project.agents:
            if agent.type == 'LlmAgent':
                for tool in agent.tools:
                    if tool.type == 'builtin' and tool.name:
                        builtin_tools.add(tool.name)
        
        if 'exit_loop' in builtin_tools:
            imports.add('from google.adk.tools import exit_loop')
        if 'google_search' in builtin_tools:
            imports.add('from google.adk.tools import google_search')
        if 'load_memory' in builtin_tools:
            imports.add('from google.adk.tools import load_memory')
        
        # MCP tools
        has_mcp = any(
            a.type == 'LlmAgent' and any(t.type == 'mcp' for t in a.tools)
            for a in self.project.agents
        )
        if has_mcp:
            imports.add('from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset')
            
            # Check connection types
            has_stdio = False
            has_sse = False
            for agent in self.project.agents:
                if agent.type == 'LlmAgent':
                    for tool in agent.tools:
                        if tool.type == 'mcp' and tool.server:
                            if tool.server.connection_type.value == 'stdio':
                                has_stdio = True
                            elif tool.server.connection_type.value == 'sse':
                                has_sse = True
            
            if has_stdio:
                imports.add('from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams')
            if has_sse:
                imports.add('from google.adk.tools.mcp_tool.mcp_session_manager import SseConnectionParams')
        
        # Custom tools - check if ToolContext is needed
        if self.project.custom_tools:
            imports.add('from google.adk.tools.tool_context import ToolContext')
        
        # Custom callbacks - check if CallbackContext is needed
        if self.project.custom_callbacks:
            imports.add('from google.adk.agents.callback_context import CallbackContext')
            imports.add('from google.adk.models.llm_response import LlmResponse')
            imports.add('from google.genai import types')
            imports.add('from typing import Optional')
        
        # Add collected imports from code
        imports.update(self._collected_imports)
        
        # Sort imports
        sorted_imports = sorted(imports)
        return '\n'.join(sorted_imports)
    
    def _generate_custom_tools(self) -> str:
        """Generate custom tool functions."""
        if not self.project.custom_tools:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# Custom Tools')
        lines.append('# =============================================================================')
        lines.append('')
        
        for tool in self.project.custom_tools:
            code, extracted_imports = _strip_imports_from_code(tool.code)
            self._collected_imports.update(extracted_imports)
            lines.append(code)
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_custom_callbacks(self) -> str:
        """Generate custom callback functions."""
        if not self.project.custom_callbacks:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# Custom Callbacks')
        lines.append('# =============================================================================')
        lines.append('')
        
        for callback in self.project.custom_callbacks:
            code, extracted_imports = _strip_imports_from_code(callback.code)
            self._collected_imports.update(extracted_imports)
            lines.append(code)
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_mcp_toolsets(self) -> str:
        """Generate MCP toolset definitions."""
        # Collect all unique MCP servers used by agents
        used_servers: Dict[str, Any] = {}
        
        for agent in self.project.agents:
            if agent.type == 'LlmAgent':
                for tool in agent.tools:
                    if tool.type == 'mcp' and tool.server:
                        used_servers[tool.server.name] = tool.server
        
        if not used_servers:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# MCP Server Toolsets')
        lines.append('# =============================================================================')
        lines.append('')
        
        for server in used_servers.values():
            var_name = _to_valid_identifier(server.name) + '_tools'
            
            if server.connection_type.value == 'stdio':
                lines.append(f'{var_name} = MCPToolset(')
                lines.append('    connection_params=StdioConnectionParams(')
                lines.append('        server_params={')
                if server.command:
                    lines.append(f'            "command": "{server.command}",')
                if server.args:
                    lines.append(f'            "args": {json.dumps(server.args)},')
                if server.env:
                    lines.append(f'            "env": {json.dumps(server.env)},')
                lines.append('        },')
                if server.timeout:
                    lines.append(f'        timeout={server.timeout},')
                lines.append('    ),')
                if server.tool_filter:
                    lines.append(f'    tool_filter={json.dumps(server.tool_filter)},')
                if server.tool_name_prefix:
                    lines.append(f'    tool_name_prefix="{server.tool_name_prefix}",')
                lines.append(')')
            
            elif server.connection_type.value == 'sse':
                lines.append(f'{var_name} = MCPToolset(')
                lines.append('    connection_params=SseConnectionParams(')
                if server.url:
                    lines.append(f'        url="{server.url}",')
                if server.headers:
                    lines.append(f'        headers={json.dumps(server.headers)},')
                if server.timeout:
                    lines.append(f'        timeout={server.timeout},')
                lines.append('    ),')
                if server.tool_filter:
                    lines.append(f'    tool_filter={json.dumps(server.tool_filter)},')
                if server.tool_name_prefix:
                    lines.append(f'    tool_name_prefix="{server.tool_name_prefix}",')
                lines.append(')')
            
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_skillsets(self) -> str:
        """Generate SkillSet definitions.
        
        Note: SkillSets use local storage and are not directly portable.
        For truly portable code, users would need to set up their own vector store.
        """
        # Collect used skillsets
        used_skillset_ids: Set[str] = set()
        for agent in self.project.agents:
            if agent.type == 'LlmAgent':
                for tool in agent.tools:
                    if tool.type == 'skillset':
                        used_skillset_ids.add(tool.skillset_id)
        
        if not used_skillset_ids:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# SkillSets (Vector Database Toolsets)')
        lines.append('# NOTE: SkillSets store data locally in ~/.adk-playground/skillsets/')
        lines.append('# For production, consider using a cloud vector database.')
        lines.append('# =============================================================================')
        lines.append('')
        
        # Add SkillSet imports
        self._collected_imports.add('from skillset import SkillSet')
        self._collected_imports.add('from knowledge_service import KnowledgeServiceManager')
        
        for skillset_id in used_skillset_ids:
            skillset = next((s for s in self.project.skillsets if s.id == skillset_id), None)
            if not skillset:
                continue
            
            var_name = _to_valid_identifier(skillset.name) + '_skillset'
            manager_name = _to_valid_identifier(skillset.name) + '_manager'
            
            lines.append(f'{manager_name} = KnowledgeServiceManager()')
            lines.append(f'{var_name} = SkillSet(')
            lines.append(f'    skillset_id="{skillset.id}",')
            lines.append(f'    project_id="{self.project.id}",')
            lines.append(f'    manager={manager_name},')
            lines.append(f'    model_name="{skillset.embedding_model or "text-embedding-004"}",')
            lines.append(f'    search_enabled={skillset.search_enabled},')
            lines.append(f'    preload_enabled={skillset.preload_enabled},')
            lines.append(f'    preload_top_k={skillset.preload_top_k},')
            lines.append(f'    preload_min_score={skillset.preload_min_score},')
            lines.append(')')
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_models(self) -> str:
        """Generate model definitions."""
        models = []
        
        for agent in self.project.agents:
            if agent.type == 'LlmAgent' and agent.model:
                var_name = _to_valid_identifier(agent.name) + '_model'
                model_code = self._generate_model_code(agent.model, var_name)
                if model_code:
                    models.append(model_code)
        
        if not models:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# Models')
        lines.append('# =============================================================================')
        lines.append('')
        lines.extend(models)
        
        return '\n'.join(lines)
    
    def _generate_model_code(self, model: ModelConfig, var_name: str) -> str:
        """Generate code for a single model."""
        if model.provider == 'litellm':
            params = [f'model="{model.model_name}"']
            if model.api_base:
                params.append(f'api_base="{model.api_base}"')
            if model.fallbacks:
                params.append(f'fallbacks={json.dumps(model.fallbacks)}')
            return f'{var_name} = LiteLlm(\n    ' + ',\n    '.join(params) + '\n)\n'
        
        elif model.provider == 'anthropic':
            return f'{var_name} = Claude(model="{model.model_name}")\n'
        
        else:
            # Gemini - just use string
            return f'{var_name} = "{model.model_name}"  # Gemini model\n'
    
    def _generate_agents(self) -> str:
        """Generate agent definitions in topological order."""
        # Topologically sort agents (sub-agents before parents)
        sorted_agents = self._topological_sort_agents()
        
        if not sorted_agents:
            return ''
        
        lines = ['# =============================================================================']
        lines.append('# Agents')
        lines.append('# =============================================================================')
        lines.append('')
        
        for agent in sorted_agents:
            lines.append(self._generate_single_agent(agent))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _topological_sort_agents(self) -> List[AgentConfig]:
        """Sort agents so sub-agents come before their parents."""
        sorted_agents = []
        visited = set()
        
        def visit(agent_id: str):
            if agent_id in visited:
                return
            agent = next((a for a in self.project.agents if a.id == agent_id), None)
            if not agent:
                return
            
            # Visit sub-agents first
            for sub_id in agent.sub_agents:
                visit(sub_id)
            
            visited.add(agent_id)
            sorted_agents.append(agent)
        
        for agent in self.project.agents:
            visit(agent.id)
        
        return sorted_agents
    
    def _generate_single_agent(self, agent: AgentConfig) -> str:
        """Generate code for a single agent."""
        var_name = self.agent_var_names[agent.id]
        
        if agent.type == 'LlmAgent':
            return self._generate_llm_agent(agent, var_name)
        elif agent.type == 'SequentialAgent':
            return self._generate_sequential_agent(agent, var_name)
        elif agent.type == 'LoopAgent':
            return self._generate_loop_agent(agent, var_name)
        elif agent.type == 'ParallelAgent':
            return self._generate_parallel_agent(agent, var_name)
        else:
            return f'# Unknown agent type: {agent.type}'
    
    def _generate_llm_agent(self, agent: LlmAgentConfig, var_name: str) -> str:
        """Generate code for an LlmAgent."""
        params = [f'name="{agent.name}"']
        
        # Model
        if agent.model:
            model_var = _to_valid_identifier(agent.name) + '_model'
            params.append(f'model={model_var}')
        
        # Instruction
        if agent.instruction:
            escaped = _escape_string(agent.instruction)
            params.append(f'instruction="""{escaped}"""')
        
        # Description
        if agent.description:
            escaped = _escape_string(agent.description)
            params.append(f'description="{escaped}"')
        
        # Output key
        if agent.output_key:
            params.append(f'output_key="{agent.output_key}"')
        
        # Include contents
        if agent.include_contents == 'none':
            params.append('include_contents="none"')
        
        # Transfer settings
        if agent.disallow_transfer_to_parent:
            params.append('disallow_transfer_to_parent=True')
        if agent.disallow_transfer_to_peers:
            params.append('disallow_transfer_to_peers=True')
        
        # Tools
        tools = self._generate_tools_list(agent.tools)
        if tools:
            params.append(f'tools=[{", ".join(tools)}]')
        
        # Sub-agents
        if agent.sub_agents:
            sub_vars = [self.agent_var_names.get(sa_id, 'unknown_agent') for sa_id in agent.sub_agents]
            params.append(f'sub_agents=[{", ".join(sub_vars)}]')
        
        # Callbacks - use actual function references, not strings!
        callback_mapping = {
            'before_agent_callbacks': 'before_agent_callback',
            'after_agent_callbacks': 'after_agent_callback',
            'before_model_callbacks': 'before_model_callback',
            'after_model_callbacks': 'after_model_callback',
            'before_tool_callbacks': 'before_tool_callback',
            'after_tool_callbacks': 'after_tool_callback',
        }
        
        for config_attr, adk_attr in callback_mapping.items():
            callbacks = getattr(agent, config_attr, [])
            if callbacks:
                func_names = self._get_callback_function_names(callbacks)
                if func_names:
                    if len(func_names) == 1:
                        params.append(f'{adk_attr}={func_names[0]}')
                    else:
                        params.append(f'{adk_attr}=[{", ".join(func_names)}]')
        
        # Build the agent definition
        return f'{var_name} = Agent(\n    ' + ',\n    '.join(params) + '\n)'
    
    def _get_callback_function_names(self, callbacks: List[CallbackConfig]) -> List[str]:
        """Get function names for callbacks (actual function references, not strings)."""
        func_names = []
        for callback in callbacks:
            # Find the callback definition
            callback_def = next(
                (cb for cb in self.project.custom_callbacks if cb.module_path == callback.module_path),
                None
            )
            if callback_def:
                # Extract function name from code or use the name field
                func_name = _get_function_name_from_code(callback_def.code)
                if not func_name:
                    func_name = callback_def.name
                func_names.append(func_name)
        return func_names
    
    def _generate_tools_list(self, tools: List[ToolConfig]) -> List[str]:
        """Generate the list of tools for an agent."""
        tool_refs = []
        
        for tool in tools:
            if tool.type == 'builtin':
                tool_refs.append(tool.name)
            
            elif tool.type == 'function':
                # Custom function tool - use the function name directly
                custom_tool = next(
                    (t for t in self.project.custom_tools if t.name == tool.name),
                    None
                )
                if custom_tool:
                    func_name = _get_function_name_from_code(custom_tool.code)
                    if func_name:
                        tool_refs.append(func_name)
                    else:
                        tool_refs.append(tool.name)
            
            elif tool.type == 'mcp':
                if tool.server:
                    var_name = _to_valid_identifier(tool.server.name) + '_tools'
                    tool_refs.append(var_name)
            
            elif tool.type == 'skillset':
                skillset = next(
                    (s for s in self.project.skillsets if s.id == tool.skillset_id),
                    None
                )
                if skillset:
                    var_name = _to_valid_identifier(skillset.name) + '_skillset'
                    tool_refs.append(var_name)
            
            elif tool.type == 'agent':
                agent_var = self.agent_var_names.get(tool.agent_id, 'unknown_agent')
                tool_refs.append(f'AgentTool(agent={agent_var})')
        
        return tool_refs
    
    def _generate_sequential_agent(self, agent: SequentialAgentConfig, var_name: str) -> str:
        """Generate code for a SequentialAgent."""
        sub_vars = [self.agent_var_names.get(sa_id, 'unknown_agent') for sa_id in agent.sub_agents]
        
        params = [
            f'name="{agent.name}"',
            f'sub_agents=[{", ".join(sub_vars)}]',
        ]
        if agent.description:
            params.insert(1, f'description="{_escape_string(agent.description)}"')
        
        return f'{var_name} = SequentialAgent(\n    ' + ',\n    '.join(params) + '\n)'
    
    def _generate_loop_agent(self, agent: LoopAgentConfig, var_name: str) -> str:
        """Generate code for a LoopAgent."""
        sub_vars = [self.agent_var_names.get(sa_id, 'unknown_agent') for sa_id in agent.sub_agents]
        
        params = [
            f'name="{agent.name}"',
            f'sub_agents=[{", ".join(sub_vars)}]',
        ]
        if agent.description:
            params.insert(1, f'description="{_escape_string(agent.description)}"')
        if agent.max_iterations:
            params.append(f'max_iterations={agent.max_iterations}')
        
        return f'{var_name} = LoopAgent(\n    ' + ',\n    '.join(params) + '\n)'
    
    def _generate_parallel_agent(self, agent: ParallelAgentConfig, var_name: str) -> str:
        """Generate code for a ParallelAgent."""
        sub_vars = [self.agent_var_names.get(sa_id, 'unknown_agent') for sa_id in agent.sub_agents]
        
        params = [
            f'name="{agent.name}"',
            f'sub_agents=[{", ".join(sub_vars)}]',
        ]
        if agent.description:
            params.insert(1, f'description="{_escape_string(agent.description)}"')
        
        return f'{var_name} = ParallelAgent(\n    ' + ',\n    '.join(params) + '\n)'
    
    def _generate_app(self) -> str:
        """Generate the App definition."""
        root_agent = next(
            (a for a in self.project.agents if a.id == self.project.app.root_agent_id),
            None
        )
        if not root_agent:
            # Use first agent if no root specified
            root_agent = self.project.agents[0] if self.project.agents else None
        
        if not root_agent:
            return '# No agents defined\nroot_agent = None'
        
        root_var = self.agent_var_names.get(root_agent.id, 'unknown_agent')
        
        lines = ['# =============================================================================']
        lines.append('# Root Agent Export')
        lines.append('# This is the entry point for adk run and adk web')
        lines.append('# =============================================================================')
        lines.append('')
        lines.append(f'root_agent = {root_var}')
        
        return '\n'.join(lines)


def generate_code(project: Project) -> str:
    """Generate complete, runnable Python code from a Project.
    
    Args:
        project: The Project to generate code for
        
    Returns:
        Complete Python code that can be run with `adk run` or `adk web`
    """
    generator = CodeGenerator(project)
    return generator.generate()


def write_agent_directory(project: Project, output_dir: Path) -> Path:
    """Write a complete agent directory that can be run with adk.
    
    Creates:
    - output_dir/agent.py - Main agent code
    - output_dir/__init__.py - Package init
    
    Args:
        project: The Project to generate code for
        output_dir: Directory to write to
        
    Returns:
        Path to the generated agent.py file
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate the code
    code = generate_code(project)
    
    # Write agent.py
    agent_file = output_dir / "agent.py"
    agent_file.write_text(code)
    
    # Write __init__.py
    init_file = output_dir / "__init__.py"
    init_file.write_text(f'"""Generated agent package for {project.name}."""\n\nfrom .agent import root_agent\n')
    
    return agent_file
