"""
Code Executor - Executes generated Python code to create agents.

This module takes the Python code generated by code_generator.py and executes it
to create the actual ADK Agent objects. This ensures that the code shown in the
Code tab is exactly what gets executed.
"""

import sys
import os
import tempfile
import logging
from pathlib import Path
from typing import Dict, Any, Optional

from models import Project

logger = logging.getLogger(__name__)


class CodeExecutor:
    """
    Executes generated Python code to build ADK agents.
    
    This class:
    1. Writes custom tools and callbacks to temporary files
    2. Adds the temp directory to sys.path
    3. Executes the generated code in a controlled namespace
    4. Extracts the created agents and app
    """
    
    def __init__(self, projects_dir: Path):
        self.projects_dir = projects_dir
        self._temp_dirs: Dict[str, tempfile.TemporaryDirectory] = {}
    
    def execute(
        self, 
        project: Project,
        generated_code: str,
        tracking_plugin: Optional[Any] = None,
    ) -> Dict[str, Any]:
        """
        Execute the generated Python code and return the created objects.
        
        Args:
            project: The Project configuration
            generated_code: Python code string from code_generator
            tracking_plugin: Optional tracking plugin for callback wrapping
            
        Returns:
            Dict containing 'agents', 'app', 'root_agent' keys
        """
        # Clean up previous temp dir for this project if exists
        if project.id in self._temp_dirs:
            try:
                self._temp_dirs[project.id].cleanup()
            except Exception:
                pass
        
        # Create temp directory for this project's code
        temp_dir = tempfile.TemporaryDirectory(prefix=f"adk_playground_{project.id}_")
        self._temp_dirs[project.id] = temp_dir
        temp_path = Path(temp_dir.name)
        
        logger.info(f"Executing generated code in temp dir: {temp_path}")
        
        # Write custom tools to tools module
        if project.custom_tools:
            tools_code = self._generate_tools_module(project)
            tools_file = temp_path / "tools.py"
            tools_file.write_text(tools_code)
            logger.debug(f"Wrote tools module to {tools_file}")
        
        # Write custom callbacks to callbacks module
        if project.custom_callbacks:
            callbacks_code = self._generate_callbacks_module(project, tracking_plugin)
            callbacks_file = temp_path / "callbacks.py"
            callbacks_file.write_text(callbacks_code)
            logger.debug(f"Wrote callbacks module to {callbacks_file}")
            
            # Also create callbacks/__init__.py and callbacks/custom.py for backwards compat
            callbacks_dir = temp_path / "callbacks"
            callbacks_dir.mkdir(exist_ok=True)
            (callbacks_dir / "__init__.py").write_text("")
            (callbacks_dir / "custom.py").write_text(callbacks_code)
        
        # Create __init__.py in temp dir
        (temp_path / "__init__.py").write_text("")
        
        # Add temp directory and backend directory to sys.path
        backend_dir = Path(__file__).parent
        paths_to_add = [str(temp_path), str(backend_dir)]
        
        # Remove any stale module caches
        self._clear_module_cache(["tools", "callbacks", "callbacks.custom", "skillset", "knowledge_service"])
        
        original_path = sys.path.copy()
        try:
            # Prepend paths to sys.path
            for p in reversed(paths_to_add):
                if p not in sys.path:
                    sys.path.insert(0, p)
            
            # Create execution namespace with necessary imports pre-loaded
            namespace = self._create_namespace(project, tracking_plugin)
            
            # Modify the generated code to use the pre-imported modules
            # and wrap callbacks with tracking
            modified_code = self._modify_code_for_execution(
                generated_code, project, tracking_plugin
            )
            
            logger.debug(f"Executing modified code:\n{modified_code[:500]}...")
            
            # Execute the code
            exec(compile(modified_code, "<generated>", "exec"), namespace)
            
            # Extract results
            result = {
                "app": namespace.get("app"),
                "root_agent": namespace.get("root_agent"),
                "agents": {},
            }
            
            # Find all agent objects in namespace
            from google.adk.agents.base_agent import BaseAgent
            for name, obj in namespace.items():
                if isinstance(obj, BaseAgent):
                    result["agents"][obj.name] = obj
            
            logger.info(f"Successfully executed code, found {len(result['agents'])} agents")
            return result
            
        except Exception as e:
            logger.error(f"Error executing generated code: {e}", exc_info=True)
            raise
        finally:
            # Restore original sys.path
            sys.path = original_path
    
    def _generate_tools_module(self, project: Project) -> str:
        """Generate the tools.py module content."""
        lines = [
            '"""Custom tools for the project."""',
            "",
            "from typing import Any, Optional",
            "",
        ]
        
        for tool in project.custom_tools:
            lines.append(tool.code)
            lines.append("")
        
        return "\n".join(lines)
    
    def _generate_callbacks_module(
        self, 
        project: Project, 
        tracking_plugin: Optional[Any] = None
    ) -> str:
        """Generate the callbacks.py module content with optional tracking."""
        lines = [
            '"""Custom callbacks for the project."""',
            "",
            "from typing import Any, Optional",
            "from google.adk.agents.callback_context import CallbackContext",
            "from google.genai import types",
            "",
        ]
        
        for callback in project.custom_callbacks:
            lines.append(callback.code)
            lines.append("")
        
        return "\n".join(lines)
    
    def _create_namespace(
        self, 
        project: Project, 
        tracking_plugin: Optional[Any] = None
    ) -> Dict[str, Any]:
        """Create the execution namespace with pre-imported modules."""
        namespace = {
            "__builtins__": __builtins__,
            "__name__": "__main__",
            "__file__": "<generated>",
        }
        
        # Pre-import ADK modules
        try:
            from google.adk.agents import Agent
            from google.adk.apps import App
            namespace["Agent"] = Agent
            namespace["App"] = App
        except ImportError as e:
            logger.warning(f"Could not import ADK core: {e}")
        
        try:
            from google.adk.agents import SequentialAgent, LoopAgent, ParallelAgent
            namespace["SequentialAgent"] = SequentialAgent
            namespace["LoopAgent"] = LoopAgent
            namespace["ParallelAgent"] = ParallelAgent
        except ImportError:
            pass
        
        try:
            from google.adk.tools import exit_loop, google_search, AgentTool
            namespace["exit_loop"] = exit_loop
            namespace["google_search"] = google_search
            namespace["AgentTool"] = AgentTool
        except ImportError:
            pass
        
        try:
            from google.adk.models.lite_llm import LiteLlm
            namespace["LiteLlm"] = LiteLlm
        except ImportError:
            pass
        
        try:
            from google.adk.plugins import ReflectAndRetryToolPlugin
            namespace["ReflectAndRetryToolPlugin"] = ReflectAndRetryToolPlugin
        except ImportError:
            pass
        
        # MCP imports
        try:
            from google.adk.tools.mcp_tool.mcp_toolset import McpToolset
            from google.adk.tools.mcp_tool.mcp_session_manager import (
                StdioConnectionParams, SseConnectionParams
            )
            namespace["McpToolset"] = McpToolset
            namespace["StdioConnectionParams"] = StdioConnectionParams
            namespace["SseConnectionParams"] = SseConnectionParams
        except ImportError:
            pass
        
        try:
            from mcp import StdioServerParameters
            namespace["StdioServerParameters"] = StdioServerParameters
        except ImportError:
            pass
        
        # SkillSet imports (local modules)
        try:
            from skillset import SkillSet
            from knowledge_service import KnowledgeServiceManager
            namespace["SkillSet"] = SkillSet
            namespace["KnowledgeServiceManager"] = KnowledgeServiceManager
        except ImportError:
            pass
        
        # Import custom tools
        if project.custom_tools:
            try:
                import tools
                for tool in project.custom_tools:
                    if hasattr(tools, tool.name):
                        namespace[tool.name] = getattr(tools, tool.name)
            except ImportError:
                logger.warning("Could not import tools module")
        
        # Import custom callbacks and wrap with tracking if needed
        if project.custom_callbacks:
            try:
                import callbacks
                for callback in project.custom_callbacks:
                    if hasattr(callbacks, callback.name):
                        callback_func = getattr(callbacks, callback.name)
                        
                        # Wrap with tracking if plugin provided
                        if tracking_plugin:
                            callback_func = self._wrap_callback_for_tracking(
                                callback_func, 
                                callback.name,
                                callback.callback_type,
                                callback.module_path,
                                tracking_plugin
                            )
                        
                        namespace[callback.name] = callback_func
            except ImportError:
                logger.warning("Could not import callbacks module")
        
        return namespace
    
    def _wrap_callback_for_tracking(
        self,
        callback_func: Any,
        name: str,
        callback_type: str,
        module_path: str,
        tracking_plugin: Any,
    ) -> Any:
        """Wrap a callback function to emit tracking events."""
        import functools
        import inspect
        import time
        import traceback
        from runtime import RunEvent
        
        if inspect.iscoroutinefunction(callback_func):
            @functools.wraps(callback_func)
            async def wrapped_async(*args, **kwargs):
                # Emit start event
                await tracking_plugin._emit(RunEvent(
                    timestamp=time.time(),
                    event_type="callback_start",
                    agent_name="",
                    data={
                        "callback_name": name,
                        "callback_type": callback_type,
                        "module_path": module_path,
                    },
                ))
                
                try:
                    result = await callback_func(*args, **kwargs)
                    
                    await tracking_plugin._emit(RunEvent(
                        timestamp=time.time(),
                        event_type="callback_end",
                        agent_name="",
                        data={
                            "callback_name": name,
                            "callback_type": callback_type,
                            "module_path": module_path,
                        },
                    ))
                    
                    return result
                except Exception as e:
                    await tracking_plugin._emit(RunEvent(
                        timestamp=time.time(),
                        event_type="callback_end",
                        agent_name="",
                        data={
                            "callback_name": name,
                            "callback_type": callback_type,
                            "module_path": module_path,
                            "error": str(e),
                            "error_type": type(e).__name__,
                            "stack_trace": traceback.format_exc(),
                        },
                    ))
                    raise
            
            return wrapped_async
        else:
            @functools.wraps(callback_func)
            def wrapped_sync(*args, **kwargs):
                return callback_func(*args, **kwargs)
            
            return wrapped_sync
    
    def _modify_code_for_execution(
        self,
        generated_code: str,
        project: Project,
        tracking_plugin: Optional[Any] = None,
    ) -> str:
        """
        Modify generated code for execution.
        
        - Remove import statements (we pre-import everything)
        - Replace callback string references with actual function references
        """
        lines = generated_code.split("\n")
        modified_lines = []
        
        in_import_section = False
        
        for line in lines:
            stripped = line.strip()
            
            # Skip import statements (we pre-import)
            if stripped.startswith("from ") or stripped.startswith("import "):
                in_import_section = True
                continue
            
            # Skip blank lines right after imports
            if in_import_section and not stripped:
                continue
            
            in_import_section = False
            modified_lines.append(line)
        
        return "\n".join(modified_lines)
    
    def _clear_module_cache(self, module_names: list):
        """Remove modules from sys.modules to force fresh imports."""
        for mod_name in list(sys.modules.keys()):
            for pattern in module_names:
                if mod_name == pattern or mod_name.startswith(pattern + "."):
                    del sys.modules[mod_name]
                    logger.debug(f"Removed {mod_name} from module cache")
                    break
    
    def cleanup(self, project_id: str = None):
        """Clean up temporary directories."""
        if project_id:
            if project_id in self._temp_dirs:
                try:
                    self._temp_dirs[project_id].cleanup()
                    del self._temp_dirs[project_id]
                except Exception:
                    pass
        else:
            for temp_dir in self._temp_dirs.values():
                try:
                    temp_dir.cleanup()
                except Exception:
                    pass
            self._temp_dirs.clear()

